<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>立方体</title>
	<script src="../lib/webgl-utils.js"></script>
	<script src="../lib/webgl-debug.js"></script>
	<script src="../lib/cuon-utils.js"></script>
	<script src="../lib/cuon-matrix.js"></script>
</head>
<body onload="main()">
	<canvas id="webgl" width="500" height="500"></canvas>
</body>
<script>
	// 顶点着色器
	var vshader_source = `
		attribute vec4 a_Position;
		attribute vec4 a_Color;
		uniform mat4 u_MvpMatrix;

		varying vec4 v_Color;
		void main () {
			gl_Position = u_MvpMatrix * a_Position;
			v_Color = a_Color;
		}
	`
	// 片元着色器
	var fshader_source = `
		precision mediump float;
		varying vec4 v_Color;
		void main () {
			gl_FragColor = v_Color;
		}
	`
	var ANGLE_STEP = 50.0;
	function main() {
		var canvas = document.getElementById('webgl');
		var gl = getWebGLContext(canvas);

		// 初始化着色器
		if (!initShaders(gl, vshader_source, fshader_source)) {
			console.log('fail');
		}

		// 初始化buffer
		var n = initVertexBuffer(gl);

		gl.clearColor(0,1,1,1);
		gl.enable(gl.DEPTH_TEST);

		// 获取attribute
		var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');

		var mvpMatrix = new Matrix4();
		var currentAngle = 0.0;
		var tick = function() {
			currentAngle = animate(currentAngle);
			draw(gl, n, currentAngle, u_MvpMatrix, mvpMatrix);
			requestAnimationFrame(tick);
		}
		tick();

		// 清除颜色和深度缓冲区
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		// 绘画
		gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
	}

	function initVertexBuffer(gl) {
		var vertices = new Float32Array([
			1,1,1, -1,1,1, -1,-1,1, 1,-1,1, 			// front
			1,1,1, 1,-1,1, 1,-1,-1, 1,1,-1, 			// right
			1,1,1, 1,1,-1, -1,1,-1, -1,1,1, 			// up
			-1,1,1, -1,1,-1, -1,-1,-1, -1,-1,1, 		// left
			-1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1, 		// down
			1,-1,-1, -1,-1,-1, -1,1,-1, 1,1,-1, 		// back
		])
		var colors = new Float32Array([
			1,0,0, 1,0,0, 1,0,0, 1,0,0,    // 前
			0,1,0, 0,1,0, 0,1,0, 0,1,0,    // 右
			0,0,0, 0,0,0, 0,0,0, 0,0,0,    // 上
			1,1,0, 1,1,0, 1,1,0, 1,1,0,    // 左
			1,0,1, 1,0,1, 1,0,1, 1,0,1,    // 下
			0,1,1, 0,1,1, 0,1,1, 0,1,1,    // 后
		]);
		var indices = new Uint8Array([
			0,1,2, 0,2,3,
			4,5,6, 4,6,7,
			8,9,10, 8,10,11,
			12,13,14, 12,14,15,
			16,17,18, 16,18,19,
			20,21,22, 20,22,23,
		])

		if (!initBuffer(gl, vertices, 3, gl.FLOAT, 'a_Position')) {
			return false;
		}
		if (!initBuffer(gl, colors, 3, gl.FLOAT, 'a_Color')) {
			return false;
		}
		var indexbuffer = gl.createBuffer();

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexbuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

		return indices.length;
	}
	function initBuffer(gl, data, num, type, attribute) {
		var buffer = gl.createBuffer();

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
		var a_attribute = gl.getAttribLocation(gl.program, attribute);
		gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);
		gl.enableVertexAttribArray(a_attribute);

		return true;
	}
	function draw(gl, n, currentAngle, u_MvpMatrix, mvpMatrix) {
		
		mvpMatrix.setPerspective(30, 1, 1, 100);
		mvpMatrix.rotate(currentAngle, 0, 0, 1.6);
		mvpMatrix.lookAt(2, 3, 9, 0, 0, 0, 0, 1, 0);

		gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
	}
	var g_last = Date.now();
	function animate(angle) {
		var now = new Date();
		var temp = now - g_last;
		g_last = now;
		var newAngle = angle + (ANGLE_STEP * temp)/1000;
		return newAngle %= 360;
	}
</script>
</html>